---
description: 
globs: 
alwaysApply: false
---
# Payload CMS Migrations Guide

This guide summarizes how migrations work in Payload CMS.

## Configuration

1.  **`package.json` script:** Ensure you have a `payload` script defined:
    ```json
    {
      "scripts": {
        "payload": "cross-env PAYLOAD_CONFIG_PATH=src/payload.config.ts payload"
      }
    }
    ```
    *Run migrations using your package manager (e.g., `npm run payload migrate`).*

2.  **Migrations Directory:**
    *   Default location: `./src/migrations`
    *   Can be configured via the `migrationDir` property in the DB adapter settings. Payload might also search common locations like `./dist/migrations` or `./migrations`.

## Migration File Structure

Each migration file exports two async functions:

*   `up({ payload, req, ... })`: Contains the logic to apply the migration changes. Receives adapter-specific arguments (like `session` for MongoDB, `db` for Postgres/SQLite).
*   `down({ payload, req, ... })`: Contains the logic to revert the changes made by the `up` function if it fails.

**Example:**
```typescript
import { MigrateUpArgs, MigrateDownArgs } from '@payloadcms/your-db-adapter' // Replace with your actual adapter

export async function up({ payload, req }: MigrateUpArgs): Promise<void> {
  // Apply changes using payload Local API or direct DB access
  // Pass `req` or adapter-specific transaction handles (e.g., `session`, `db`)
}

export async function down({ payload, req }: MigrateDownArgs): Promise<void> {
  // Revert changes made in the `up` function
}
```

## Transactions

*   Each migration runs within a transaction by default (except SQLite where it's disabled by default).
*   Pass the `req` object (or adapter-specific args like `session` or `db`) to Payload Local API calls or direct database operations (`payload.db.*`) to include them in the transaction.
*   The transaction is automatically committed if `up` succeeds, or aborted if it fails.

## Migration Commands

Run these using your package manager (e.g., `npm run payload <command>`).

*   `migrate`: Runs pending migrations.
*   `migrate:create [name]`: Creates a new migration file (timestamped by default).
    *   `--skip-empty`: (Postgres) Skips prompt if no schema changes detected.
    *   `--force-accept-warning`: Accepts prompts, creates blank migration even with no schema changes.
*   `migrate:status`: Shows the status of all migrations.
*   `migrate:down`: Rolls back the last batch of migrations.
*   `migrate:refresh`: Rolls back all migrations and runs them again.
*   `migrate:reset`: Rolls back all migrations.
*   `migrate:fresh`: Drops all database entities and re-runs all migrations.

## Workflow Differences

*   **MongoDB:** Migrations are mainly needed for transforming existing data when the schema changes significantly. You might run them manually or in CI.
*   **Postgres (and other relational DBs):** Migrations are crucial for *any* schema change (new fields, collections).
    *   **Local Development (Recommended):** Use Drizzle's `push` mode (enabled by default: `push: true` in adapter config). It automatically syncs schema changes to your *local* DB. **Do not mix `push` and `migrate` commands on the same local DB.** Create migrations *after* local development is complete, but don't run them locally if using `push`.
    *   **CI/Build Process:** Run `payload migrate` *before* your build command (e.g., `npm run build`). This applies pending migrations to your staging/production database.
      ```json
      "scripts": {
        "dev": "...",
        "build": "next build", // Or your build command
        "payload": "...",
        "ci": "payload migrate && pnpm build" // Example build script
      }
      ```
    *   **Production Runtime (Long-running servers):** You can run migrations when the server starts by passing them to the adapter:
      ```typescript
      // src/payload.config.ts
      import { migrations } from './migrations' // Assuming Payload generates this index
      import { buildConfig } from 'payload'
      import { postgresAdapter } from '@payloadcms/db-postgres' // Or your adapter

      export default buildConfig({
        // ... other config
        db: postgresAdapter({
          // ... adapter config
          prodMigrations: migrations,
        }),
      })
      ```
      *Warning: This can slow down serverless cold starts.*

## Best Practices

*   Complete a feature or task before creating a migration.
*   Review auto-generated migration files before committing them.
*   Run migrations in CI/build pipelines for production environments.
*   Use `push` mode for local development with relational databases.
