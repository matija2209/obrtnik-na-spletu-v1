---
description: 
globs: 
alwaysApply: false
---
Okay, incorporating the specific file structure, naming conventions, and UI library context, here's the refined summary on using Server Actions with forms, `useActionState`, and `useOptimistic` in your Next.js project:

**Key Takeaway:** Server Actions provide a powerful way to handle form submissions and mutations directly from your components, integrating seamlessly with React hooks for state management and optimistic UI updates.

**1. Defining and Organizing Server Actions**

*   **Core Concept:** Server Actions are async functions running on the server, marked with the `"use server"` directive.
*   **Best Practice: Separate Files:** **Crucially, define your Server Actions in dedicated files, separate from your component definitions.** This improves organization, reusability, and separation of concerns.
*   **File Structure & Naming:**
    *   Place your action files within a dedicated directory, like `src/actions/`.
    *   Organize actions by domain or feature (e.g., `src/actions/user-actions.ts`, `src/actions/payment-actions.ts`, `src/actions/league-actions.ts`, `src/actions/event-actions.ts`).
    *   Use **kebab-casing** for filenames.
    *   Add `"use server"` at the *very top* of each action file. This marks all exported functions in that file as Server Actions.
    ```typescript
    // src/actions/user-actions.ts
    'use server';

    import { z } from 'zod';
    // ... other imports

    export async function createUser(prevState: any, formData: FormData) {
      // ... validation and database logic
      // Return state for useActionState or redirect
    }

    export async function updateUserProfile(userId: string, formData: FormData) {
      // ... server logic
    }
    ```

**2. Using Server Actions with Forms (`<form>` in `src/(admin)/components/forms/`)**

*   **UI Context:** You're using `shadcn/ui`. While the fundamental `form` and hook usage is React/Next.js based, you'll integrate Server Actions with `shadcn/ui`'s `Form` component (which often uses `react-hook-form` internally, but can also work directly with Server Actions) or basic HTML `<form>`.
*   **Direct `<form action>`:** For simpler forms or when not using `react-hook-form`'s full feature set with `shadcn/ui`, you can use the standard HTML `<form>` and assign your imported Server Action directly to the `action` prop.
    ```typescript
    // src/admin/components/forms/create-user-form.tsx
    'use client'; // Forms often need client-side interactivity

    import { createUser } from '@/actions/user-actions';
    import { Input } from '@/components/ui/input'; // shadcn/ui component
    import { Button } from '@/components/ui/button'; // shadcn/ui component
    import { useActionState } from 'react';

    const initialState = { message: '' };

    export function CreateUserForm() {
      const [state, formAction, isPending] = useActionState(createUser, initialState);

      return (
        <form action={formAction} className="space-y-4">
          {/* Use shadcn/ui Input or other form components */}
          <Input name="email" type="email" placeholder="Email" required />
          <Input name="name" type="text" placeholder="Name" required />

          {state?.message && <p className="text-sm text-red-600">{state.message}</p>}

          <Button type="submit" disabled={isPending}>
            {isPending ? 'Creating...' : 'Create User'}
          </Button>
        </form>
      );
    }
    ```
*   **Integrating with `shadcn/ui`'s `Form` (using `react-hook-form`):** If using the `shadcn/ui` `Form` component built on `react-hook-form`, you typically handle submission via `react-hook-form`'s `handleSubmit` and call your Server Action *inside* the submit handler function. `useActionState` and `useOptimistic` can still be used alongside this pattern.
*   **FormData:** Actions receive `FormData`. Use `formData.get('fieldName')`.
*   **Passing Extra Args:** Use `action.bind(null, arg1, ...)` to pass non-form data.

**3. Handling Form State with `useActionState` (Client Components)**

*   **Purpose:** Manage loading states and display responses/errors directly from the Server Action. **Requires a Client Component.**
*   **Hook:** `const [state, formAction, isPending] = useActionState(yourServerAction, initialState);`
*   **Action Signature:** Your Server Action's *first* parameter must accept the `previousState`.
    ```typescript
    // src/actions/user-actions.ts
    'use server';
    export async function createUser(prevState: { message: string; errors?: any }, formData: FormData) {
      // ... validation (e.g., with Zod)
      // if (!validatedFields.success) {
      //   return { message: 'Validation Failed', errors: validatedFields.error.flatten().fieldErrors };
      // }
      // ... DB logic
      // On success: return { message: 'Success!' } or redirect()
      // On failure: return { message: 'Database error.' }
    }
    ```
*   **Initial State:** Define a serializable `initialState` object matching the expected return shape of your action (especially for messages/errors).
    ```typescript
    // In your form component:
    const initialState = { message: '', errors: null };
    const [state, formAction, isPending] = useActionState(createUser, initialState);
    ```
*   **Usage:**
    *   Use the returned `formAction` in your `<form action={formAction}>`.
    *   Use `isPending` to show loading states (e.g., disable `shadcn/ui` Button).
    *   Display feedback using the `state` object (`state.message`, `state.errors`).

**4. Optimistic Updates with `useOptimistic` (Client Components)**

*   **Purpose:** Update UI instantly *before* the server confirms, providing a faster perceived experience. **Requires a Client Component.**
*   **Hook:** `const [optimisticState, addOptimisticUpdate] = useOptimistic(actualState, updateFn);`
*   **Usage:**
    1.  Maintain your "real" state (could be from props, `useState`, or data fetched via Next.js).
    2.  Use `useOptimistic`, passing the real state and an update function `(currentState, optimisticValue) => newState`.
    3.  Create a wrapper function for your form `action` or event handler.
    4.  Inside the wrapper, call `addOptimisticUpdate(value)` *immediately*.
    5.  Then, `await` your actual Server Action.
    6.  Render your UI using the `optimisticState`.
*   **Reversion:** React automatically reverts the optimistic update if the Server Action promise rejects (throws an error). Successful actions typically lead to data revalidation (`revalidatePath`/`Tag`), which updates the "real" state, aligning it with the (now confirmed) optimistic state.

```typescript
// Example concept (simplified) - src/admin/components/features/toggle-feature-flag.tsx
'use client';
import { useOptimistic } from 'react';
import { toggleFeatureFlagAction } from '@/actions/feature-flag-actions'; // Assumed action
import { Switch } from '@/components/ui/switch'; // shadcn/ui

export function FeatureFlagToggle({ id, initialIsEnabled }: { id: string; initialIsEnabled: boolean }) {
  const [optimisticIsEnabled, setOptimisticIsEnabled] = useOptimistic(
    initialIsEnabled,
    (currentState, optimisticValue: boolean) => optimisticValue // Simple toggle case
  );

  const actionHandler = async () => {
    const newValue = !optimisticIsEnabled;
    setOptimisticIsEnabled(newValue); // Update UI immediately
    try {
      await toggleFeatureFlagAction(id, newValue); // Call server action
      // Revalidation likely happens within the action
    } catch (e) {
      console.error("Failed to toggle feature flag", e);
      // Optimistic state automatically reverts on error
    }
  };

  return (
     // Use a form for progressive enhancement, even with onClick-like behavior
    <form action={actionHandler}>
        <Switch
            checked={optimisticIsEnabled}
            // Note: For complex forms, direct binding might be needed,
            // but for a simple switch, triggering the form action works.
            // We use the form's action, not onCheckedChange directly for Server Action pattern
            type="submit" // Make the switch trigger the form submission
            aria-label={`Toggle feature ${id}`}
        />
    </form>
  );
}
```

**5. Other Best Practices**

*   **Validation:** Always validate server-side (e.g., `zod`). Return structured errors for `useActionState`.
*   **Security:** Check authentication/authorization within every action. Treat them as API endpoints.
*   **Revalidation:** Use `revalidatePath` or `revalidateTag` after successful mutations.
*   **Redirects:** Use `redirect` after success/revalidation when navigation is needed.
*   **Error Handling:** Use `try/catch` in actions; return errors for `useActionState` or let them bubble up.

By following these guidelines, especially organizing actions into `src/actions/` with kebab-casing and leveraging `useActionState` and `useOptimistic` within your `shadcn/ui` forms in `src/(admin)/components/forms/`, you can build robust and user-friendly data mutation flows.

## 6. Pattern: Server Component Fetching for Client Component Forms

A common and recommended pattern, especially for **edit** or **delete** forms (or any form needing initial server-fetched data), is to structure your components as follows:

1.  **Parent Server Component (`page.tsx` or layout):**
    *   Marked as `async`.
    *   Fetches the necessary initial data (e.g., the entity to be edited/deleted, related data for dropdowns).
    *   Handles `params` or `searchParams` (remembering they are `Promise`s in Next.js 15+ and need `await`).
    *   Renders the Client Component form, passing the fetched data down as props.

2.  **Child Client Component (`_components/your-form.tsx`):**
    *   Marked with `'use client'`.
    *   Receives initial data via props from the Server Component parent.
    *   Contains the `<form>` element.
    *   Uses hooks like `useActionState` to manage the form submission state (pending, errors, success messages) by binding it to a Server Action.
    *   May use `useEffect` to react to state changes (e.g., show toasts) after the action completes.
    *   Handles user interactions (button clicks, input changes if needed).

**Example (`src/app/admin/events/[id]/delete/page.tsx` and `_components/delete-standalone-event-form.tsx`):**

```typescript
// src/app/admin/events/[id]/delete/page.tsx (Server Component)
import { notFound } from 'next/navigation';
import { AdminPageHeader } from '@/components/admin-dashboard/misc/admin-page-header';
import { getEventById } from '@/repositories';
import { DeleteStandaloneEventForm } from './_components/delete-standalone-event-form'; // Import Client Component

interface DeleteEventPageProps {
  params: Promise<{ id: string }>;
}

export default async function DeleteEventPage({ params }: DeleteEventPageProps) {
  const { id: eventId } = await params; // Await params
  const event = await getEventById(eventId); // Fetch data

  if (!event) {
    notFound();
  }

  // Prepare breadcrumbs, etc.
  const breadcrumbs = [/* ... */];

  return (
    <AdminPageHeader title={`Delete Event: ${event.title}`} breadcrumbs={breadcrumbs}>
      {/* Render Client Component, passing fetched data */}
      <DeleteStandaloneEventForm eventId={eventId} eventTitle={event.title} />
    </AdminPageHeader>
  );
}

// src/app/admin/events/[id]/delete/_components/delete-standalone-event-form.tsx (Client Component)
'use client';

import { useActionState, useEffect } from 'react';
import { deleteStandaloneEvent } from '@/actions/events/delete-standalone-event'; // Import Server Action
import { Button } from '@/components/ui/button';
import { toast } from 'sonner';
// ... other imports

interface DeleteStandaloneEventFormProps {
  eventId: string;
  eventTitle: string;
}

const initialState = { success: false, message: undefined };

export function DeleteStandaloneEventForm({ eventId, eventTitle }: DeleteStandaloneEventFormProps) {
  const [state, formAction, isPending] = useActionState(deleteStandaloneEvent, initialState);

  useEffect(() => {
      if (state.message && !state.success) {
          toast.error(state.message);
      }
      // Success is handled by redirect in the action
  }, [state]);

  return (
    <form action={formAction} className="mt-4 space-y-4">
      <input type="hidden" name="eventId" value={eventId} />
      <p>Are you sure you want to delete "{eventTitle}"?</p>
      {/* ... rest of form, buttons with isPending state */}
      <Button type="submit" disabled={isPending} variant="destructive">
          {isPending ? 'Deleting...' : 'Yes, delete'}
      </Button>
      {/* ... Cancel button */}
    </form>
  );
}
```

**Benefits:**

*   **Server-Side Data Loading:** Leverages Server Components for efficient initial data fetching.
*   **Client-Side Interactivity:** Uses Client Components for necessary hooks (`useActionState`, `useEffect`, `useState`) and event handling.
*   **Clear Separation:** Keeps data fetching logic separate from form interaction logic.
*   **Performance:** Avoids fetching data on the client that's already available on the server at render time.

This pattern provides a robust way to build forms that interact with Server Actions while benefiting from initial data loading on the server.